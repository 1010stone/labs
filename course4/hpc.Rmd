---
layout: page
title: "Architecture: considerations on high performance computing with Bioconductor"
---

```{r options, echo=FALSE}
library(knitr)
opts_chunk$set(fig.path=paste0("figure/", sub("(.*).Rmd","\\1",basename(knitr:::knit_concord$get('infile'))), "-"))
```
```{r getpacksa,echo=FALSE,results="hide"}
library(RNAseqData.HNRNPC.bam.chr14)
library(Rsamtools)
library(GenomicRanges)
library(GenomicAlignments)
library(parallel)
library(BiocParallel)
```

## Overview of performance enhancements

There are two main approaches to achieving scalability of
analytical workflows in Bioconductor.

- Shared memory parallelism.  The R process is forked an
arbitrary number of times with full copies of the memory
image and computations proceed independently for each image.
Selected results are returned to the master process.  This
is often effective in multicore environments.

- Distributed parallelism.  Independent processors, potentially
running different operating systems, can run compatible instances
of R.  Job control can be carried out by R or by a cluster scheduler.

For tasks that are "embarrassingly parallel", that do not require
communication between processes beyond starting, stopping, and
returning results, either of these approaches can be used
reasonably simply in R.

### Simple illustration

We can demonstrate the shared memory approach with our laptop.

```{r lkm1}
system.time( lapply(1:8, function(x)Sys.sleep(1) ) )
library(parallel)
detectCores()
options(mc.cores=4)
system.time( mclapply(1:8, function(x)Sys.sleep(1) ) )
```

For this meaningless computation, we achieved linear speedup:
we cut the time for serial computation by a factor of four.

### Implicit parallelism through BiocParallel

To foster harmonious development of reliably performant procedures,
Bioconductor introduced the BiocParallel package.  Users
benefit from autonomous (but optionally controllable) pursuit
of parallel computing when feasible.  Consider the following
example: we will count reads into bins defined by exon addresses
in the HNRNPC example dataset.  This is an RNA-seq study to
determine the effects of HNRNPC knockdown on Alu exonization.
BAM files are assembled with aligned reads limited to chr14.

```{r lkbam}
library(RNAseqData.HNRNPC.bam.chr14)
fns = RNAseqData.HNRNPC.bam.chr14_BAMFILES
library(GenomicAlignments)
length(fns)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
txdb = TxDb.Hsapiens.UCSC.hg19.knownGene
ii = isActiveSeq(txdb)
ii[] = FALSE
ii[14] = TRUE
isActiveSeq(txdb) = ii
ebg = exonsBy(txdb, by="gene")
# summarizeOverlaps uses bplapply to iterate over files
system.time(i1 <- summarizeOverlaps( ebg, fns[1] ))
system.time(i2 <- summarizeOverlaps( ebg, fns ))
```
This is not a thorough way of measuring speedup but it
shows reasonable enhancement.  We have to watch the memory
consumption.  If process size is large, we may want to leave
some cores idle.  We can accomplish that by using `register`.
```{r lkbp}
library(BiocParallel)
register(MulticoreParam(workers=2))
system.time(i3 <- summarizeOverlaps( ebg, fns ))
all.equal(i3,i2)
```


