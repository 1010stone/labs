---
title: "Chromosomes and their substructures"
author: "Vince"
date: "March 19, 2015"
output: html_document
layout: page
toc: yes
---

```{r setup,echo=FALSE,results="hide"}
suppressPackageStartupMessages({
library(BSgenome.Hsapiens.NCBI.GRCh38)
library(Biostrings)
library(GenomicRanges)
library(IRanges)
})
```

# Genomic sequence, reference builds

## Human

The genomic sequence for humans has recently
been revised.  We can use the most recent major
revision as follows:

```{r hg38}
library(BSgenome.Hsapiens.NCBI.GRCh38)
Hsapiens
h38 = Hsapiens # for later
```

Notice the number of sequences reported, and their names.  We can
get the sequence for a chromosome by using list-like
syntax with `Hsapiens`.

```{r lkc22}
h38$"22"
```

This shows that the starting and ending bases are indeterminate.
We can obtain the overall nucleotide frequencies as

```{r lkf}
alphabetFrequency(Hsapiens$"22")
```

A great deal of reference data in use are annotated to 
build hg19 (also known as GRCh37).

```{r lk19}
library(BSgenome.Hsapiens.UCSC.hg19)
Hsapiens
h19 = Hsapiens
```

Note that there is a different sequence naming convention
and a different number of sequences managed in this build.


## Other organisms

If you have an internet connection, the `available.genomes` function
will list packages that contain reference sequences.

```{r lkav, eval=FALSE}
available.genomes()
```
 
For organisms not covered at present by the project, tools
for building compatible packages are available in the
BSgenome package (see the BSgenomeForge vignette).

# Biostrings: basic infrastructure for computing on sequences

## Construction, sets, restricted alphabets

Very large strings like chromosome sequences receive
special handling in Bioconductor.  We use a general container
class called `BString` for "big" strings that are
distringuished from R character vectors in that BStrings a) obey
different rules for copying and b) do not contain multiple
strings (see the man page for BString).  Classes `DNAString`
and `AAString` have restrictions on the characters that can be
managed in instances.

```{r lkbs}
library(Biostrings)
bdemo = BString("BCDEF")
ddemo = try(DNAString("BCDEF"))
cat(ddemo)
ademo = try(AAString("BCDEF"))
```

Efficient management of multiple strings employs classes with
"Set" as suffix.
```{r lkds}
ddem2 = DNAStringSet(c("ACTG", "GTCAG"))
ddem2
```

The restrictions on contents of genomic strings are defined
in constant vectors in `Biostrings`.  For example
```{r lkcon}
AA_ALPHABET
IUPAC_CODE_MAP
```

## Operations

There are over 200 functions defined in the Biostrings package,
all devoted to computation on sequence data.  Here's an
example illustrating basic notions.

```{r doop}
D = DNAString("ACTGACGTACGTAGGCTAGCGATCGATATACGATATACG")
translate(D)
codons(D)
```

Notice that the output of codons is printed as a `Views` instance.
This is a very efficient approach to creating references to
subsequences of a sequence, without copying any data.

# Organizing genomic sequences: GRanges

It is seldom of great interest to compute with the
entire chromosomal sequence.  Subsequences formed of
contiguous bases are used to define genes and other
genomic elements, and coincidences of subsequences (for
example, sequences defining locations of variants and
sequences defining locations of promoters) should
be efficiently computable.

## IRanges, the low-level support infrastructure

The IRanges package provides a very basic and efficient
set of structures and tools for manipulating intervals,
defined as sequences of consecutive integers.  The IRanges
instances can be handled as vectors of intervals.

### Construction and arithmetic

```{r lkira}
library(IRanges)
i1 = IRanges(start=c(3,4,5,6), end=c(400,450,20, 122))
i2 = IRanges(start=c(34,52,68,777), end=c(4400,1450,209, 2122))
i1
```

Arithmetic on IRanges instances is specialized.  Ranges
contract when a constant (vector) is subtracted from them, and expand when
a constant (vector) is added. 

```{r doima}
i2-10
i1+(1:4)
```

### Reduce, disjoin, gaps

We'll borrow some code from the IRanges vignette to illustrate
additional ideas.

```{r plotr,echo=FALSE}
plotRanges <- function(x, xlim = x, main = deparse(substitute(x)),
                       col = "black", sep = 0.5, ...)
{
  height <- 1
  if (is(xlim, "Ranges"))
    xlim <- c(min(start(xlim)), max(end(xlim)))
  bins <- disjointBins(IRanges(start(x), end(x) + 1))
  plot.new()
  plot.window(xlim, c(0, max(bins)*(height + sep)))
  ybottom <- bins * (sep + height) - height
  rect(start(x)-0.5, ybottom, end(x)+0.5, ybottom + height, col = col, ...)
  title(main)
  axis(1)
}
```
```{r newr}
ir <- IRanges(c(1, 8, 14, 15, 19, 34, 40),
  width = c(12, 6, 6, 15, 6, 2, 7))
```

First, let's visualize `ir`:
```{r lkir,fig.height=2.25}
plotRanges(ir)
```
Operations reduce, disjoin, and gaps have the following results:
```{r lkir2,fig.height=2.25}
plotRanges(reduce(ir))
```
```{r lkir3,fig.height=2.25}
plotRanges(disjoin(ir))
```
```{r lkir4,fig.height=2.25}
plotRanges(gaps(ir))
```

### findOverlaps

We'll create another IRanges instance to illustrate findOverlaps.
```{r neewo}
ir2 = IRanges(19,21)
findOverlaps(ir, ir2)
```

`findOverlaps` creates a `Hits` instance which can be
queried for indices of query or subject ranges satisfying
the overlap conditions.

```{r newooo,fig=TRUE}
 par(mfrow=c(3,1))
 plotRanges(ir, xlim=c(0,50))
 plotRanges(ir2, xlim=c(0,50))
 plotRanges(ir[queryHits(findOverlaps(ir,ir2))], xlim=c(0,50))
```

### Partitionings
